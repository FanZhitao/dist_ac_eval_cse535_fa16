import logging
from msg.evalreq import EvalReq
from msg.evalresp import EvalResp
from msg.commitreq import CommitReq
from msg.commitresp import CommitResp

log = logging.getLogger('Worker')

class Worker(process):
    def setup(db:set):
        self.policy = None
        
    def run():
        log.info("Worker %s is up.", self)
        #p = next(iter(db))
        send(('getpolicy'), to=db)
        log.info("Sending message to database %s to fetch policy and waiting for response.", db)
        while True:
            await(received(()))

    def receive(msg=('assignreq', resp), from_=rc):
        log.info("Received evaluation request from resource coodinator: %s", rc)
        #send(('getupdaterecords'), to=db)
        #log.info("Sending message to database %s to get records.", db)
        #self.resp = resp
        #await(received(('records')))

        # In case not received policy from database yet.
        if self.policy == None:
            await(received(('records')))

        # Evaluate request and send the result back to subject coordinator.
        resp, rule = evaluate(resp)
        if resp.decision == True:
            # Has found a matched rule.
            # Update attributes according to the obligation
            resp = updateAttributes(resp, rule)
        #send(('respeval', resp,), to=resp.scAdm)

    def receive(msg=('policy', policy), from_=p):
        log.info("Received policy data from database: %s", p)
        log.info("policy: %s", policy)
        self.policy = policy

    def receive(msg=('records', records), from_=p):
        log.info("Received updated records from database: %s", p)
        log.info("records: %s", records)
        result = evaluate(None, None)
        #send(('evalresult'), to=self.resp.scAdm)

    def evaluate(resp:EvalResp):
        resp.decision = False
        matchedRule = None

        for rule in policy.iter('rule'): # rule is an ElementTree instance
            # check if conditions satisfy the current rule
            should_try_next_rule = False # flag used to continue outter for loop

            # subject
            should_try_next_rule = not doAttributesMatch(rule.find('subjectCondition'), resp.subrattr)

            if should_try_next_rule == True:
                continue

            # resource
            # TODO: copy subject code

            if should_try_next_rule == True:
                continue

            # action
            action_rule = rule.find('action')
            action_rule = action_rule['name']
            if action_rule == resp.action:
                # all subject, resource, and action satisfied
                resp.decision = True
                matchedRule = rule
                break

        return (resp, matchedRule)

    def doAttributesMatch(condition:dict, attributes:dict):
        for attribute_name in iter(condition.attrib):
            if attribute_name not in attributes:
                # keys do not match
                return False

            # keys match, then check values
            value_condition = condition.attrib[attribute_name]
            value_attribute = attributes[attribute_name]
            # need to deal with different value forms
            # case 1: $subject.ATTRIBUTE or $resource.ATTRIBUTE
            if value_condition.startswith("$"):
                dot_index = value_condition.index(".")
                attribute_key = value_condition[dot_index + 1 :]
                sub_or_res = value_condition[0 : dot_index]
                if sub_or_res == 'subject':
                    value = resp.subraddr[attribute_key]
                elif sub_or_res == 'resource':
                    value = resp.resraddr[attribute_key]
                else:
                    # TODO: Throw invalid policy exception
                    pass

                if value != value_attribute:
                    return False

            # case 2: <constant or >constant
            if value_condition.startswith("<"):
                num_str = value_condition[1:]
                if not num_str.isnumeric():
                    # the attribute value is not a numberic string
                    return False

                # valid, then compare them
                num_condition = int(num_str)
                num_attribute = int(value_attribute)
                if num_attribute >= num_condition:
                    return False

            # TODO: >

            # case 3: constant
            if value_condition != value_attribute:
                return False

        # all passed
        return True

    def updateAttributes(resp:EvalResp, rule:Element):
        # subject update
        if 'subjectUpdate' in rule:
            attributeElement = rule.find('subjectUpdate')
            attributes = attributeElement.attrib
            for attribute_name in attributes:
                value_to_update = attributes[attribute_name]
                # different update value forms
                # case 1: ++ or --
                if value_to_update == '++':
                    resp.subwattr[attribute_name] += 1
                # TODO: --

                # case 2: constant
                # case 2.1: no such key exists -> create a new k,v pair
                if not attribute_name in resp.subwattr:
                    resp.subwattr[attribute_name] = value_to_update
                else:
                    # case 2.2: append the value
                    resp.subwattr[attribute_name].append(value_to_update)

        # TODO: copy & paste resource part

def main():
    # test cases to simlulate messages from resource coordinators
    resp = EvalResp()
