import logging
from msg.evalreq import EvalReq
from msg.evalresp import EvalResp
from msg.commitreq import CommitReq
from msg.commitresp import CommitResp

log = logging.getLogger('Worker')

class Worker(process):
    def setup(db:set):
        self.policy = None
        
    def run():
        log.info("Worker %s is up.", self)
        p = next(iter(db))
        send(('getpolicy'), to=p)
        log.info("Sending message to database %s to fetch policy and waiting for response.", db)
        while True:
            await(received(()))

    def receive(msg=('assigneval', req), from_=rc):
        log.info("Received evaluation request from resource coodinator: %s", rc)

        # In case not received policy from database yet.
        if self.policy == None:
            log.info("No policy received yet. Waiting for response from database.")
            await(received(('records')))

        # Evaluate request and send the result back to subject coordinator.
        resp, rule = evaluate(req)
        if resp.decision == True:
            # Has found a matched rule.
            # Add read and write attributes into
            # resq.{subrattr, subwattr, resrattr, reswattr}.
            resp = add_read_write_attributes(req, resp, rule)
        log.info("Send response to subject coordinator [%s]", req.sc)
        send(('respeval', resp), to=req.sc)

    def receive(msg=('policy', policy), from_=p):
        log.info("Received policy data from database: %s", p)
        log.info("policy: %s", policy)
        self.policy = policy

    def evaluate(req:EvalReq):
        log.info("Start to evaluate req: [%d]", req.seq)
        resp = EvalResp(req) # construct response based on request
        resp.decision = False
        matchedRule = None

        for rule in policy.iter('rule'): # rule is an ElementTree instance
            #log.info("Trying to match rule [%s]", rule.attrib['name'])
            # check if conditions satisfy the current rule
            should_try_next_rule = False # flag used to continue outter for loop

            # subject
            should_try_next_rule = not do_attributes_match(rule.find('subjectCondition'), req.subattr, req)
            if should_try_next_rule == True:
                continue
            #log.info("Subject condition satisfied.")

            # resource
            should_try_next_rule = not do_attributes_match(rule.find('resourceCondition'), req.resattr, req)
            if should_try_next_rule == True:
                continue
            #log.info("Resource condition satisfied.")

            # action
            action_rule = rule.find('action')
            action_rule = action_rule.attrib['name']
            #log.info("Comparing action in rule: %s with %s", action_rule, req.action)
            if action_rule == req.action:
                # all subject, resource, and action satisfied
                #log.info("Action matched.")
                log.info("Corresponding rule found: [%s]. granting access...", rule.attrib['name'])
                resp.decision = True
                matchedRule = rule
                break

        return (resp, matchedRule)

    def do_attributes_match(condition:dict, attributes:dict, req:EvalReq):
        #log.info("Comparing rule %s with %s", condition.attrib, attributes)
        for attribute_name in iter(condition.attrib):
            if attribute_name not in attributes.keys():
                # keys do not match
                #log.info('Key "%s" not found', attribute_name)
                return False

            # keys match, then check values
            #log.info('Key "%s" mathced, comparing values.', attribute_name)
            value_condition = condition.attrib[attribute_name]
            value_attribute = attributes[attribute_name]
            # need to deal with different value forms
            # case 1: $subject.ATTRIBUTE or $resource.ATTRIBUTE
            if value_condition.startswith("$"):
                dot_index = value_condition.index(".")
                attribute_key = value_condition[dot_index + 1 :]
                sub_or_res = value_condition[0 : dot_index]
                if sub_or_res == 'subject':
                    value = req.subraddr[attribute_key]
                elif sub_or_res == 'resource':
                    value = req.resraddr[attribute_key]
                else:
                    # TODO: Throw invalid policy exception
                    pass

                if value != value_attribute:
                    return False

            # case 2: <constant or >constant
            elif value_condition.startswith("<"):
                num_str = value_condition[1:]
                if not num_str.isnumeric():
                    # the attribute value is not a numberic string
                    return False

                # valid, then compare them
                num_condition = int(num_str)
                if value_attribute >= num_condition:
                    return False

            elif value_condition.startswith(">"):
                num_str = value_condition[1:]
                if not num_str.isnumeric():
                    # the attribute value is not a numberic string
                    return False

                # valid, then compare them
                num_condition = int(num_str)
                if value_attribute <= num_condition:
                    return False

            # case 3: constant
            elif value_condition != value_attribute:
                return False

        # all passed
        return True

    def add_read_write_attributes(req:EvalReq, resp:EvalResp, rule:Element):
        # Copy attributes from request.
        # subject attributes
        for attribute_name in req.subattr:
            resp.subrattr.append(attribute_name) # read attributes
            resp.subwattr[attribute_name] = req.subattr[attribute_name] # write attributes with initial values from request
        # resource attributes
        for attribute_name in req.resattr:
            resp.resrattr.append(attribute_name) # read attributes
            resp.reswattr[attribute_name] = req.resattr[attribute_name] # write attributes

        # Modify write attributes according to obligation
        # subject attributes update
        fulfill_obligation(rule, 'subjectUpdate', resp.subwattr)
        # resource attributes update
        fulfill_obligation(rule, 'resourceUpdate', resp.reswattr)
        return resp

    def fulfill_obligation(rule:Element, sub_or_res:str, attrs_to_update:dict):
        obligation_element = rule.find(sub_or_res)
        if obligation_element != None:
            attributes = obligation_element.attrib
            for attribute_name in attributes:
                value_to_update = attributes[attribute_name]
                # different update value forms
                # case 1: ++ or --
                if value_to_update == '++' or value_to_update == '--':
                    # case 1.1: no such key exists -> create a new k,v pair with value 0
                    # e.g. viewCount
                    if not attribute_name in attrs_to_update:
                        attrs_to_update[attribute_name] = 0
                    attrs_to_update[attribute_name] += 1
                    log.info("Obligation: %s=%s. New value: %d", attribute_name, value_to_update, attrs_to_update[attribute_name])
                    continue

                # case 2: constant -> write (or overwrite) the value
                attrs_to_update[attribute_name] = value_to_update
                log.info("Obligation: %s=%s. New value: %s", attribute_name, value_to_update, attrs_to_update[attribute_name])

def main():
    # test cases to simlulate messages from resource coordinators
    resp = EvalResp()
