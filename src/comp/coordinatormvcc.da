import logging
import time
import queue

from db.db import DB
from util.router import Router
from util.idgen import IdGen
from util.analyzer import Analyzer
from util.dynanalyzer import DynAnalyzer
from state.adminmvcc import AdminMvcc
from msg.evalreqmvcc import EvalReqMvcc
from msg.evalrespmvcc import EvalRespMvcc

log = logging.getLogger("Coordinator")

class CoordinatorMvcc(process):

    def setup(workers:set, db:DB, cfg):
        logging.basicConfig(level=logging.INFO, 
            format='[%(asctime)s] %(name)s:%(levelname)s: %(message)s')
        self.router = None
        self.analyzer = None
        self.admin = AdminMvcc(db)
        self.idgen = IdGen()
        self.activereq = set()
        self.pendingwrt = dict()

    def run():
        log.info("Coordinator [%s] is up", self)
        while True:
            await(received(('done')))

    def receive(msg=('prepare', router, analyzer)):
        """
        Receive route table and analyzer from master process
        """
        log.info("Coord - Received route table and analyzer")
        self.router = router
        self.analyzer = DynAnalyzer(analyzer)
        self.analyzer.admin = self.admin

    def receive(msg=('reqapp', req,), from_=p):
        """
        coord1: Received request from Application
        """
        log.info("Coord1 - Incoming application request: #seq=[%d] object=[%s]", req.seq, self.analyzer.obj(req, 1))
        delay(req.seq, 'reqapp')

        req.app = p
        handle_request(req, 1)
        nextco = self.router.route(self.analyzer.obj(req, 2))
        log.info("Coord1 - Send evaluation request to Coord2: #seq=[%d], to=%s\n", req.seq, nextco)
        send(('reqeval', req), to=nextco)

    def receive(msg=('reqeval', req,), from_=p):
        """
        coord2: Received request from Coordinator 1
        """
        log.info("Coord2 - Incoming application request: #seq=[%d] object=[%s]", req.seq, self.analyzer.obj(req, 2))
        delay(req.seq, 'reqeval')

        handle_request(req, 2)
        worker = next(iter(workers))
        log.info("Coord2 - Assign evalution request: #seq=[%d] to worker=[%s]\n", req.seq, worker)
        send(('assigneval', req), to=worker)

        # Test
        resp = EvalRespMvcc(req)
        resp.updatedObj = 2 # Suppose correctly predict
        resp.rdonlydObj = 1
        resp.updates = { 'history': req.resource }
        resp.readAttr[2] = list()
        resp.readAttr[2].append('history')
        send(('respeval', resp), to=self)

    def receive(msg=('respeval', resp), from_=p):
        """
        coordW: Receive evaluation result from worker
        """
        log.info("CoordW - Incoming evaluation response from worker: #seq=[%d] object=[%s]", resp.seq, self.analyzer.obj(resp, resp.updatedObj))
        delay(resp.seq, 'respeval')
        if invalid_message(resp):
            return

        x = self.analyzer.obj(resp, resp.updatedObj)
        dump_current_state(resp, x)
        if not conflict(x, resp):
            # Wait for all pending read complete
            await(each(attr in resp.updates.keys(),
                has= (not self.admin.latestVersionBefore(x, attr, resp.ts).pendingMightRead) or
                        all(reqid == resp.id for reqid in self.admin.latestVersionBefore(x, attr, resp.ts).pendingMightRead)))

            if not conflict(x, resp):
                cleanup_pending_update(resp)

                # Commit update to database
                log.info("CoordW - Send attribute updates to database [%s]", self.db)
                send(('writeattr', resp.updates), to=self.db)

                # Commit update to cache and update version
                self.admin.commit_cache(x, resp)
                self.admin.update_version(x, resp)
                update_read_ts(resp, resp.updatedObj, 
                        self.analyzer.defReadAttr(x, resp) | self.analyzer.mightReadAttr(x, resp))

                # Notify application the evaluation result
                log.info("CoordW - Send evaluation result of request #seq=[%d] to application", resp.seq)
                send(('respapp', resp.seq, resp.decision), to=resp.app)

                # Notify other coordinator to update rts for attributes read
                coordR = self.router.route(self.analyzer.obj(resp, resp.rdonlydObj))
                log.info("CoordW - Send attribute read of request #seq=[%d] to CoordR [%s]", resp.seq, coordR)
                send(('readAttr', resp, resp.rdonlydObj), to=coordR)
                dump_current_state(resp, x)
            else:
                restart(resp)
        else:
            restart(resp)

    def receive(msg=('readAttr', resp, i), from_=p):
        """
        coordR: Get notified that which attr in mightReadAttr is actually read
        """
        if invalid_message(resp):
            return
        x = self.analyzer.obj(resp, i)
        log.info("Coord%d - Incoming readAttr request: #seq=[%d] object=[%s]", i, resp.seq, x)
        update_read_ts(resp, i, self.analyzer.mightReadAttr(x, resp))

    def handle_request(req, i):
        # 1.Generate unique global ID
        if req.id is None:
            req.id = self.idgen.next()
            req.ts = self.admin.now()
            log.info('Coord%d - Assign globalID=[%s] and ts=[%d] to #seq=[%s]', i, req.id, req.ts, req.seq)

        # 2.Handle potential starvation proactively: delay readonly request
        prevent_starvation_proactively(req, i)

        # 3.Setup administration
        x = self.analyzer.obj(req, i)
        defR = self.analyzer.defReadAttr(x, req)
        mgtR = self.analyzer.mightReadAttr(x, req)
        if self.analyzer.readonly(req):
            for attr in defR:
                self.admin.latestVersionBefore(x, attr, req.ts).rts = req.ts
            for attr in mgtR:
                self.admin.latestVersionBefore(x, attr, req.ts).pendingMightRead.append(req.id)
        else:
            for attr in defR | mgtR:
                self.admin.latestVersionBefore(x, attr, req.ts).pendingMightRead.append(req.id)

        # 4.Populate data piggybacked to request
        req.cachedUpdates[i] = self.admin.cachedUpdates(x, req)
        log.info("\nCoord%d - Prepare request complete: #seq=[%d], object=[%s]" + 
                "\ndefRead=[%s], \nmightRead=[%s], \nversions=[%s], \npendingwrt=[%s], \ncachedUpdates=%s", 
                i, req.seq, x, defR, mgtR,
                self.admin.versions[x] if x in self.admin.versions else None, 
                self.pendingwrt[x] if x in self.pendingwrt else None,
                str(req.cachedUpdates))

    def prevent_starvation_proactively(req, i):
        x = self.analyzer.obj(req, i)
        if self.analyzer.readonly(req):
            defR = self.analyzer.defReadAttr(x, req)
            mgtR = self.analyzer.mightReadAttr(x, req)
            wrtreq = set()
            if x in pendingwrt:
                for attr in defR | mgtR:
                    if attr in pendingwrt[x] and not all(req2.ts > req.ts for req2 in pendingwrt[x][attr]):
                        wrtreq.add(pendingwrt[x][attr])

            if not wrtreq:
                log.warn("Coord%d - *****Pending current readonly request #seq=[%d]" + 
                        "due to potentially starving write request: %s", i, req.seq, wrtreq)

            await(each(attr in defR | mgtR,
                has= ((x not in pendingwrt) or
                    (attr not in pendingwrt[x]) or
                    all(req2.ts > req.ts for req2 in pendingwrt[x][attr]))))
        else:
            for attr in self.analyzer.mightWriteAttr(x, req):
                if x not in pendingwrt:
                    pendingwrt[x] = dict()
                if attr not in pendingwrt[x]:
                    pendingwrt[x][attr] = set()
                pendingwrt[x][attr].add((req.id, req.ts))
                log.info("Coord%d - Current write request #seq=[%d] might write obj=[%s] attr=[%s]", 
                        i, req.seq, x, attr) 

    def update_read_ts(resp, i, attrs):
        x = self.analyzer.obj(resp, i)
        for attr in attrs:
            v = self.admin.latestVersionBefore(x, attr, resp.ts)
            v.pendingMightRead.remove(resp.id)
            if attr in resp.readAttr[i]:
                v.rts = resp.ts

    def conflict(x, resp):
        for attr, _ in resp.updates.items():
            v = self.admin.latestVersionBefore(x, attr, resp.ts)
            if v.rts > resp.ts:
                log.warn("***** Conflict *****: Request #seq=[%d] conflicts!", resp.seq)
                return True
        log.info("CoordW - no conflict found for request #seq=[%d]", resp.seq)
        return False

    def restart(resp):
        cleanup_pending_update(resp)
        req = EvalReqMvcc(resp)
        prevco = self.router.route(req, self.analyzer.obj(req, 1))
        send(('reqapp', req), to=prevco)

    def invalid_message(msg):
        return False

    def cleanup_pending_update(resp):
        pass

    def dump_current_state(resp, x):
        cache = self.admin.subcache if x == resp.subject else self.admin.rescache
        log.info("\nCoordW - === Current state dump for #seq=[%d] object=[%s] === " +
                "\nVersions=[%s] \nPending Writes=[%s], \nCache=%s",
                resp.seq, x,
                self.admin.versions[x] if x in self.admin.versions else None, 
                self.pendingwrt[x] if x in self.pendingwrt else None,
                cache[x] if x in cache else None)

    def delay(seq, method):
        key = 'req' + str(seq) + '.delay.' + method
        if key in cfg:
            log.info('***** Delay *****: #seq=[%d] %f(s) at [%s]', seq, float(cfg[key]), key)
            time.sleep(float(cfg[key]))

