import logging
import time
import queue

from db.db import DB
from util.router import Router
from util.idgen import IdGen
from util.analyzer import Analyzer
from util.dynanalyzer import DynAnalyzer
from state.adminmvcc import AdminMvcc
from msg.evalreqmvcc import EvalReqMvcc
from msg.evalrespmvcc import EvalRespMvcc

log = logging.getLogger("Coordinator")

class CoordinatorMvcc(process):

    def setup(workers:set, db:DB, cfg, analyzer:DynAnalyzer):
        self.router = None
        self.admin = AdminMvcc(db)
        self.idgen = IdGen()
        self.pendingUpdates = dict()
        self.rdonlyPendingQ = list()
        self.analyzer.admin = self.admin

    def run():
        log.info("Coordinator [%s] is up", self)
        while True:
            await(received(('done')))

    def receive(msg=('prepare', router, subattrs, resattrs)):
        """
        Receive route table and subject/resource attribute list from master process
        """
        log.debug("Coord - Received route table and subject/resource attribute list")
        self.router = router
        self.admin.init_subcache(subattrs)
        self.admin.init_rescache(resattrs)

    def receive(msg=('reqapp', req,), from_=p):
        """
        coord1: Received request from Application
        """
        log.info("Coord-1 - Incoming application request: #seq=[%d] subject=[%s]", req.seq, req.subject)
        delay(req.seq, 'reqapp')

        # Pending readonly request to prevent pending write request starvation
        if self.analyzer.readonly(req) and might_conflict(req):
            self.rdonlyPendingQ.append(req)
            log.warn("Coord-1 - pending application request due to pending write request: #seq=[%d]\n", req.seq)
        else:
            handle_request(req, 1)
            nextco = self.router.route(req, self.analyzer.obj(req, 2))
            log.info("Coord-1 - Send evaluation request to Coord-2: #seq=[%d], to=%s\n", req.seq, nextco)
            send(('reqeval', req), to=nextco)

    def receive(msg=('reqeval', req,), from_=p):
        """
        coord2: Received request from Coordinator 1
        """
        log.info("Coord-2 - Incoming application request: #seq=[%d] object=[%s]", req.seq, self.analyzer.obj(req, 2))
        delay(req.seq, 'reqeval')
        handle_request(req, 2)
        worker = next(iter(workers))
        log.info("Coord2 - Assign evalution request: #seq=[%d] to worker=[%s]\n", req.seq, worker)
        send(('assigneval', req), to=worker)

    def receive(msg=('respeval', resp), from_=p):
        """
        coordW: Receive evaluation result from worker
        """
        log.info("CoordW - Incoming evaluation response from worker: #seq=[%d]", resp.seq)
        delay(resp.seq, 'respeval')

        x = self.analyzer.obj(resp, resp.updatedObj)
        if not conflict(resp):
            # Wait for all pending read complete
            self.pendingUpdates[x] = resp.updates
            await(each((attr, val) in resp.updates,
                has= (not self.admin.latestVersionBefore(x, attr, resp.ts).pendingMightRead) or
                        all(v.wts == resp.ts for v in self.admin.latestVersionBefore(x, attr, resp.ts).pendingMightRead)))
            resume_pending_request(resp)

            if not conflict(resp):
                # Commit update to database
                log.info("CoordW - Send attribute updates to database [%s]", self.db)
                send(('writeattr', resp.updates), to=self.db)

                # Commit update to cache and update version
                self.admin.commit_cache(resp.updatedObj, resp.updates, resp.ts)
                self.admin.update_version(resp.updatedObj, resp.updates, resp.ts)
                update_read_ts(resp, resp.updatedObj, 
                        self.analyzer.defReadAttr(x, resp) | self.analyzer.mightReadAttr(x, resp))

                # Notify application the evaluation result
                send(('respapp', resp.seq, resp.decision), to=resp.app)

                # Notify other coordinator to update rts for attributes read
                coordR = self.router.route(resp, resp.rdonlydObj)
                log.info("CoordW - Send attribute read to CoordR [%s]", coordR)
                send(('readAttr', resp, resp.rdonlydObj), to=coordR)
            else:
                restart(resp)
        else:
            restart(resp)

    def receive(msg=('readAttr', resp, i), from_=p):
        """
        coordR: Get notified that which attr in mightReadAttr is actually read
        """
        x = self.analyzer.obj(resp, i)
        log.info("Coord-%d - Incoming readAttr request: #seq=[%d] object=[%s]", i, resp.seq, x)
        update_read_ts(resp, i, self.analyzer.mightReadAttr(x, resp))

    def handle_request(req, i):
        # 1.Generate unique global ID
        if req.id is None:
            req.id = self.idgen.next()
            req.ts = self.admin.now()
            log.info('Coord-%d - Assign globalID=[%s] to #seq=[%s]', req.id, req.seq)

        # 2.Setup administration
        x = self.analyzer.obj(req, i)
        defR = self.analyzer.defReadAttr(x, req)
        mgtR = self.analyzer.mightReadAttr(x, req)
        if self.analyzer.readonly(req):
            for attr in defR:
                self.admin.latestVersionBefore(x, attr, req.ts).rts = req.ts
            for attr in mgtR:
                self.admin.latestVersionBefore(x, attr, req.ts).pendingMightRead.append(req.id)
        else:
            for attr in defR | mgtR:
                self.admin.latestVersionBefore(x, attr, req.ts).pendingMightRead.append(req.id)

        # 3.Populate data piggybacked to request
        req.cachedUpdates[i] = self.admin.cachedUpdates(x, req)

    def update_read_ts(resp, i, attrs):
        x = self.analyzer.obj(resp, i)
        for attr in attrs:
            v = self.admin.latestVersionBefore(x, attr, resp.ts)
            v.pendingMightRead.remove(resp.id)
            if attr in resp.readAttr[i]:
                v.rts = resp.ts

    def conflict(resp):
        x = self.analyzer.obj(resp, 1)
        for (attr, _) in resp.updates:
            v = self.admin.latestVersionBefore(x, attr, resp.ts)
            if v.rts > resp.ts:
                return True
        return False

    def might_conflict(req):
        x = self.analyzer.obj(req, 1)
        if self.pendingUpdates[x]:
            return False
        updates = self.pendingUpdates[x]
        defR = self.analyzer.defReadAttr(x, req)
        mgtR = self.analyzer.mightReadAttr(x, req)
        return not (updates.keys() & (defR | mgtR))

    def resume_pending_request(resp):
        # Handle all pending readonly request after the waiting write request complete
        x = self.analyzer.obj(resp, resp.updatedObj)
        for req in list(self.rdonlyPendingQ):
            if self.analyzer.obj(req, 1) != x:
                continue
            self.rdonlyPendingQ.remove(req)
            handle_request(req, 1)
            nextco = self.router.route(req, self.analyzer.obj(req, 2))
            log.info("Coord-1 - Send evaluation request to Coord-2: #seq=[%d], to=%s\n", req.seq, nextco)
            send(('reqeval', req), to=nextco)
        del self.pendingUpdates[x]

    def restart(resp):
        req = EvalReqMvcc(resp)
        prevco = self.router.route(req, self.analyzer.obj(req, 1))
        send(('reqapp', req), to=prevco)

    def delay(seq, method):
        key = 'req' + str(seq) + '.delay.' + method
        if key in cfg:
            log.info('***** Delay *****: #seq=[%d] %f(s) at [%s]', seq, float(cfg[key]), key)
            time.sleep(float(cfg[key]))

