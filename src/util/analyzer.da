
import sys
import logging
import xml.etree.ElementTree as ET

SUB_READ = 1
SUB_UPD  = 2
RES_READ = 3
RES_UPD  = 4

"""
Static analyzer that preread policy rule from database to make decision of:
    Which object could possibly be involved in write
    Which object should be accessed first to reduce latency
    Is the request readonly
"""

log = logging.getLogger(__name__)

class Analyzer:

    def __init__(self, policyfile):
        self.policy = dict()
        self.parse_policy(policyfile, self.policy)

    def parse_policy(self, policyfile, policy):
        log.info("Start parsing policy file [%s]", policyfile)
        tree = ET.parse(policyfile)
        for rule in tree.getroot().iter('rule'):
            subject = rule.find('subjectCondition').attrib.get('position')
            resource = rule.find('resourceCondition').attrib.get('id')
            action = rule.find('action').attrib.get('name')
            if (subject, resource, action) not in policy:
                policy[(subject, resource, action)] = list()

            # Analyze potential read/update attributes in each rule
            cur = [list()] * 4
            for attr in rule.find('subjectCondition'):
                if attr.name == 'subjectCondition': continue
                cur[SUB_READ].append((attr.name, attr.val))
            for attr in rule.find('resourceCondition'):
                if attr.name == 'resourceCondition': continue
                cur[RES_READ].append((attr.name, attr.val))
            if rule.find('subjectUpdate'):
                for attr in rule.find('subjectUpdate'):
                    cur[SUB_UPD].append(attr.name)
            if rule.find('resourceUpdate'):
                for attr, _ in rule.find('resourceUpdate'):
                    cur[RES_UPD].append(attr.name)
            policy[(subject, resource, action)] = cur
        log.info("Parse policy file complete")

    def obj(self, req, i):
        wrtobj = self.mightWriteObj(req)
        # If written object is decided, choose it as second to process
        # Otherwise (readonly request or more than 1 written object which cannot be decided)
        # Choose subject as the first object to handle randomly
        if len(wrtobj) == 1:
            rdobj = req.subject if req.subject != wrtobj[0] else req.resource
            return rdobj if i == 1 else wrtobj[0]
        else:
            return req.subject if i == 1 else req.resource

    def readonly(self, req):
        return not self.mightWriteObj(req)

    def mightWriteObj(self, req):
        wrtobj = list()
        if self.policy[(req.subject, req.resource, req.action)][SUB_UPD]:
            wrtobj.append(req.subject)
        if self.policy[(req.subject, req.resource, req.action)][RES_UPD]:
            wrtobj.append(req.resource)
        return wrtobj

