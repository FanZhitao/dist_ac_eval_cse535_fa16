import sys
import xml.etree.ElementTree as ET
import random
import logging
import asyncio
import time
import pprint

from msg.commitresp import CommitResp

log = logging.getLogger('DB')

class DB(process):
    def setup(policy_filename:str, record_filename:str, minDBlatency:str, maxDBlatency:str, workers:set):
        log.debug("%s is setting up.", self)
        log.debug("Parsing policy file: %s", policy_filename)
        tree = ET.parse(policy_filename)
        self.rules = tree.getroot()
        log.debug("Parsing record file: %s", record_filename)
        tree = ET.parse(record_filename)
        record = tree.getroot()

        # convert record to attributes dict
        ts = time.time()
        self.subrecords = {}
        self.resrecords = {}
        self.subrecords[ts] = convert(record, 'subject')
        self.resrecords[ts] = convert(record, 'resource')

        self.actions = []
        # save possible actions
        for rule in self.rules.iter('rule'):
            action_element = rule.find('action')
            action = action_element.attrib.get('name')
            if action != None:
                self.actions.append(action)
  
        log.debug("Parsing finished.")
        log.debug("subject records: %s", self.subrecords)
        log.debug("resource records: %s", self.resrecords)

        log.debug("min and max latency: %s, %s", minDBlatency, maxDBlatency)
        if not minDBlatency.isnumeric() or not maxDBlatency.isnumeric():
            # TODO: throw exception
            pass
        minDBlatency = int(minDBlatency)
        maxDBlatency = int(maxDBlatency)
        log.debug("DB setup finished.")

    def run():
        log.info("%s is up.", self)
        while True:
            await(received(()))

    def receive(msg=('getpolicy'), from_=p):
        log.info("Received policy request message from worker %s", p)
        send(('policy', self.rules), to=p)

    def receive(msg=('writeattr', attr, ts, sub_or_res), from_=p):
        log.info("Received write attribute messages from coordinator [%s]", p)
        records = self.subrecords
        if sub_or_res == 'res':
            records = self.resrecords
        write_attrs(records, attr, ts)
        send(('writefinish', True), to=p)

    def receive(msg=('getsubs'), from_=p):
        log.info("Received subjects request from coordinator [%s]", p)
        log.info("Send subjects back to coordinator [%s]", p)
        send(('subs', self.subrecords), to=p)

    def receive(msg=('getresos'), from_=p):
        log.info("Received resources request from coordinator [%s]", p)
        log.info("Send resources back to coordinator [%s]", p)
        send(('resos', self.resrecords), to=p)

    def receive(msg=('getacts'), from_=p):
        log.info("Received actions request from coordinator [%s]", p)
        log.info("Send actions back to coordinator [%s]", p)
        send(('acts', self.actions), to=p)

    def receive(msg=('dumpdb'), from_=p):
        log.info("\n" + "=" * 10 + " Database Data " + "=" * 10 
                    + "\n Subject %s\n Resource %s\n", 
                        pprint.pformat(self.subrecords), pprint.pformat(self.resrecords))

    def receive(msg=('getattrs', req), from_=p):
        log.info("Received get attributes request from worker:%s", p)
        sub = None
        res = None
        for ts in self.subrecords.keys():
            if ts <= req.ts:
                sub = self.subrecords[ts]
        for ts in self.resrecords.keys():
            if ts <= req.ts:
                res = self.resrecords[ts]
        attrs2send['sub'] = sub
        attrs2send['res'] = res
        send(('attrs', attrs2send), to=p)

    def write_attrs(records, attr, ts):
        matched_record = None
        for ts_in_db in records.keys():
            if ts_in_db == ts:
                matched_record = records[ts]
                break

        if matched_record == None:
            # insert a record with timestamp ts
            records[ts] = attr
        else:
            # update record at timestamp ts
            for key in records[ts].keys():
                records[ts][key] = attr[key]

        # delay the visibility of updates
        l = random.randrange(minDBlatency, maxDBlatency, 1)
        log.debug("Delay %d seconds...", l)
        time.sleep(l / 100)

    def convert(record:Element, key:str):
        # convert {'id': id1, 'position': 'employee'}
        # to {'id1': {'position': 'employee'}
        result = {}
        attributes = record.findall(key)
        for element in attributes:
            attr = element.attrib
            if 'id' in attr:
                result[attr['id']] = attr
                #result[attr['id']].pop('id')
        return result