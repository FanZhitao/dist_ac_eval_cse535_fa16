
------------------
# 1.Data Structure

```
EvalReqMvcc:
# Basic fields same as Phase 1 and 2
    seq:        Sequence number indicating different request in test case
    id:         Global unique ID generated by coordinator
    app:        Request source (client)
    subject:    Subject ID
    resource:   Resource ID
    action:     Action name
# Specific fields of MVCC
    ts:             Timestamp of current request
    cachedUpdates:  piggybacked cached data in coordinator
```

```
EvalRespMvcc:
# Fields populated from Request
    seq, id, app, subject, resource, action, ts
# Specific fields of MVCC
    decision:   Evaluation result
    readAttr:   Attributes read
    updates:    Attributes updated
    updatedObj: Object updated
    rdonlydObj: Object read
```


----------
# 2.Master

Create static analyzer and specify running mode (normal or mvcc)

```

```


----------
# 3.Client (Application)

Client determine the objects possibly involved in write by the content of request and by using static analyzer which preread policy file.

```
router:     Router that has knowledge of which coordinator takes care of the object
seqfrom:    First sequence number for which current client is responsble
seqto:      Last sequence number for which current client is responsble
cfg:        Configuration for client side
subjects:   Subject ID list (used for random payload generation)
resources:  Resource ID list
actions:    Action name list
analyzer:   Static analyzer that decides which object should process first
mode:       Running mode (oplock for Phase 1/2 or mvcc for Phase 3)
 
def run():
    for i from seqfrom to seqto:
        # 0.Create request according to the running mode
        req = EvalReq() if mode == oplock else EvalReqMvcc()
        req.seq = i 

        # 1.Generate specific or random payload (req.subject, resource, action)
        #   Since it's exactly the same as that in Phase 2, so we omit the detail here...

        # 2.Send to correspondent coordinator
        if mode == oplock:
            sc = router.get_sc(req.subject)
            send(('reqapp', req,), to=sc)
        else:
            x = self.analyzer.obj(req, 1)
            co = router.route(x)
            send(('reqapp', req,), to=co)

    # 3.Wait for exit command
    await(received('done'))

def receive(msg=('respapp', seq, result,), from_=sc):
    output decision or perform other operation
```


---------------
# 4.Coordinator

```

```

## AdminMvcc (State managment helper class)

```

```


----------
# 5.Worker


------------
# 6.Database
