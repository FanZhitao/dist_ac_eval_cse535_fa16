
------------------
# 1.Data Structure

For the MVCC implementation in the Phase 3, we add two more message classes EvalReqMvcc and EvalRespMvcc.

```py
EvalReqMvcc:
# Basic fields same as Phase 1 and 2
    seq:        Sequence number indicating different request in test case
    id:         Global unique ID generated by coordinator
    app:        Request source (client)
    subject:    Subject ID
    resource:   Resource ID
    action:     Action name
# Specific fields of MVCC
    ts:             Timestamp of current request
    cachedUpdates:  piggybacked cached data in coordinator
```

```py
EvalRespMvcc:
# Fields populated from Request
    seq, id, app, subject, resource, action, ts
# Specific fields of MVCC
    decision:   Evaluation result
    readAttr:   Attributes read
    updates:    Attributes updated
    updatedObj: Object updated
    rdonlydObj: Object read
```


----------
# 2.Master

The main change of Master is the initialization of static analyzer and running mode (normal or mvcc) to distinguish code flow of Phase 3 from Phase 2.

```py

```


----------
# 3.Client (Application)

Client determine the objects possibly involved in write by the information available in current request and by using static analyzer (described in the following Coordinator section).

```py
router:     Router that has knowledge of which coordinator takes care of the object
seqfrom:    First sequence number for which current client is responsble
seqto:      Last sequence number for which current client is responsble
cfg:        Configuration for client side
subjects:   Subject ID list (used for random payload generation)
resources:  Resource ID list
actions:    Action name list
analyzer:   Static analyzer that decides which object should process first
mode:       Running mode (oplock for Phase 1/2 or mvcc for Phase 3)
sentreq:    List of request that has been sent used for timeout check
 
def run():
    for i from seqfrom to seqto:
        # 0.Create request according to the running mode
        req = EvalReq() if mode == oplock else EvalReqMvcc()
        req.seq = i 

        # 1.Generate specific or random payload (req.subject, resource, action)
        #   Since it's exactly the same as that in Phase 2, so we omit the detail here...

        # 2.Send to correspondent coordinator
        if mode == oplock:
            coord = router.get_sc(req.subject)
        else:
            x = analyzer.obj(req, 1)
            coord = router.route(x)
        send(('reqapp', req,), to=coord)
        sentreq[i] = (req, coord, current timestamp)

    # 3.Wait for exit command
    await(received('done'))

def receive(msg=('respapp', seq, result,), from_=sc):
    Output decision or perform other operation
    Delete entry sentreq[seq]
 
    # Re-submit request if timeout which is configured in config file
    for seq, req, coord, ts in sentreq.items():
        if current timestamp - ts > cfg['timeout']:
            send(('reqapp', req,), to=coord)
            sentreq[seq] = (req, coord, current timestamp)
```

## Analyzer (Static analysis helper class)

Static analyzer that preread policy rule to make decision of:

 + Which object could possibly be involved in write
 + Which object should be accessed first to reduce latency
 + Is the request readonly?

```py
policy: Analysis result of policy file
    <(subject,resource,action),
        <rule-id, [subject-read-attrs, 
                subject-update-attrs, 
                resource-read-attrs,
                resource-update-attrs]>>

def parse_policy(policyfile, policy):
    tree = ET.parse(policyfile)

    # Analyze rules one by one
    for rule in tree.getroot().iter('rule'):
        subject = find subject ID attribute value
        resource = find resource ID attribute value
        action = find action name value

        # Analyze and save read/update attributes in each rule
        # cur is analysis result of current rule
        for attr, val in subject read attributes:
            cur[SUB_READ].append((attr, val))
        for attr, val in resource read attributes:
            cur[RES_READ].append((attr, val))
        if rule has subject update attributes:
            for attr, _ in subject update attributes:
                cur[SUB_UPD].append(attr)
        if rule has resource update attributes:
            for attr, _ in resource update attributes:
                cur[RES_UPD].append(attr)
        policy[(subject, resource, action)].append(cur)

# If written object is decided, choose it as second to process
# Otherwise (readonly request or more than 1 written object which cannot be decided). Choose subject as the first object to handle randomly.
def obj(req, i):
    wrtobj = mightWriteObj(req)
    if len(wrtobj) == 1:
        rdobj = req.subject if req.subject != wrtobj[0] else req.resource
        return rdobj if i == 1 else wrtobj[0]
    else:
        return req.subject if i == 1 else req.resource

def readonly(req):
    return not mightWriteObj(req)

def mightWriteObj(req):
    wrtobj = list()
    if policy[(req.subject, req.resource, req.action)][SUB_UPD]:
        wrtobj.append(req.subject)
    if policy[(req.subject, req.resource, req.action)][RES_UPD]:
        wrtobj.append(req.resource)
    return wrtobj
```


---------------
# 4.Coordinator

```py
router: Router that has knowledge of which coordinator takes care of the object
admin:  Administrator of local state (cache and version)
idgen:  Generator of global unique ID which is exactly same as Phase 2.
hasPendingWrtReq:   Mark if any pending write request which is set to False initially
rdonlyPendingQ:     Queue for waiting readonly request coming after the pending write request

# Run and up until receiving stop command 'done'
def run():
    while True:
        await(received(('done')))

# Receive route table and subject/resource attribute list from master process
def receive(msg=('prepare', router)):
    self.router = router

# Coord1: Received request from Application
def receive(msg=('reqapp', req,), from_=p):
    if analyzer.readonly(req):
        # Pending readonly request to prevent pending write request starvation
        rdonlyPendingQ.put(req)
        if hasPendingWrtReq:
            return

        # Handle all pending readonly request after the waiting write request complete
        while not rdonlyPendingQ.empty():
            preq = rdonlyPendingQ.remove()
            handle_request(preq, 1)
            nextco = router.route(preq, analyzer.obj(preq, 2))
            send(('reqeval', preq), to=nextco)
    else:
        handle_request(req, 1)
        nextco = router.route(req, analyzer.obj(req, 2))
        send(('reqeval', req), to=nextco)

# Coord2: Received request from Coordinator 1
def receive(msg=('reqeval', req,), from_=p):
    handle_request(req, 2)
    worker = next(iter(workers))
    send(('assigneval', req), to=worker)

# CoordW: Receive evaluation result from worker
def receive(msg=('respeval', resp), from_=p):
    x = analyzer.obj(resp, resp.updatedObj)
    if not conflict(resp):
        # Wait for all pending read complete
        hasPendingWrtReq = True
        await(each((attr, val) in resp.updates,
            has= (not admin.latestVersionBefore(x, attr, resp.ts).pendingMightRead) or
                    all(v.wts == resp.ts for v in admin.latestVersionBefore(x, attr, resp.ts).pendingMightRead)))
        hasPendingWrtReq = False

        if not conflict(resp):
            # Commit update to database
            send(('writeattr', resp.updates), to=db)

            # Commit update to cache and update version
            admin.commit_cache(resp.updatedObj, resp.updates, resp.ts)
            admin.update_version(resp.updatedObj, resp.updates, resp.ts)

            # Notify application the evaluation result
            send(('respapp', resp.seq, resp.decision), to=resp.app)

            # Notify other coordinator to update rts for attributes read
            coordR = router.route(resp, resp.rdonlydObj)
            send(('readAttr', resp, resp.rdonlydObj), to=coordR)
        else:
            restart(resp)
    else:
        restart(resp)

# CoordR: Get notified that which attr in mightReadAttr is actually read
def receive(msg=('readAttr', resp, i), from_=p):
    x = obj(req, i)
    for attr in admin.mightReadAttr(x, req):
        v = admin.latestVersionBefore(x, attr, resp.ts)
        v.pendingMightRead.remove((resp.id, _))
        if attr in req.readAttr[i]:
            v.rts = req.ts

def handle_request(req, i):
    # 1.Generate unique global ID
    if req.id is None:
        req.id = idgen.next()

    # 2.Setup administration
    x = analyzer.obj(req, i)
    req.ts = admin.now()
    defR = admin.defReadAttr(x, req)
    mgtR = admin.mightReadAttr(x, req)
    if analyzer.readonly(req):
        for attr in defR:
            admin.latestVersion(x, attr).rts = req.ts
        for attr in mgtR:
            admin.latestVersion(x, attr).pendingMightRead.add((req.id, req.ts))
    else:
        for attr in defR | mgtR:
            admin.latestVersion(x, attr).pendingMightRead.add((req.id, req.ts))

    # 3.Populate data piggybacked to request
    req.cachedUpdates[i] = admin.cachedUpdates(x, req)

def conflict(resp):
    for (attr, _) in resp.updates:
        v = latestVersionBefore(x, attr, resp.ts)
        if v.rts > resp.ts:
            return True
    return False

def restart(resp):
    req = EvalReqMvcc(resp)
    prevco = router.route(req, obj(req, 1))
    send(('reqapp', req), to=prevco)
```

## AdminMvcc (State managment helper class)

Due to important changes, we add a new class AdminMvcc for MVCC state management.

```py
subcache: Subject cache that contains <obj, <attr, (value, timestamp)>>
rescache: Resource cache that contains <obj, <attr, (value, timestamp)>>
versions: Version map <obj, <attr, [v1, v2...]>> wherein each Version contains: rts (read timestamp), wts (write timestamp) and pendingMightRead (pending queue for uncertain read request)
window:   Inconsistent time window of attribute database

def commit_cache(x, updates, ts):
    cache = subcache if x in subcache else rescache
    for attr, newval in updates.items():
        cache[x][attr] = (newval, ts)

def update_version(x, updates, ts):
    for attr, _ in updates.items():
        versions[x][attr].append(Version(ts, ts))

def now():
    return current timestamp

def cachedUpates(x, req):
    cache = dict()
    if x in subcache:
        return subcache[x]
    elif x in rescache:
        return rescache[x]

    # Remove entry if live longer than inconsitent window of attribute DB
    for attr, _, ts in cache:
        if now() - ts >= window:
            delete cache[attr]
    return cache

def latestVersionBefore(x, attr, ts):
    if x not in versions:
        versions[x] = dict()
    if attr not in versions[x]:
        versions[x][attr] = list()
        versions[x][attr].append(Version(0, 0))
    return versions[x][attr][-1]

def latestVersion(x, attr):
    return latestVersionBefore(x, attr, now())
```

## DynAnalyzer (Dynamic analysis helper class)

```

```


----------
# 5.Worker


------------
# 6.Database
