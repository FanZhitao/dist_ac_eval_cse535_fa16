
------------------
# 1.Data Structure

```
EvalReqMvcc:
# Basic fields same as Phase 1 and 2
    seq:        Sequence number indicating different request in test case
    id:         Global unique ID generated by coordinator
    app:        Request source (client)
    subject:    Subject ID
    resource:   Resource ID
    action:     Action name
# Specific fields of MVCC
    ts:             Timestamp of current request
    cachedUpdates:  piggybacked cached data in coordinator
```

```
EvalRespMvcc:
# Fields populated from Request
    seq, id, app, subject, resource, action, ts
# Specific fields of MVCC
    decision:   Evaluation result
    readAttr:   Attributes read
    updates:    Attributes updated
    updatedObj: Object updated
    rdonlydObj: Object read
```


----------
# 2.Master

The main change of Master is the improvement by adding static analyzer and specifying running mode (normal or mvcc) to distinguish code flow of Phase 3 from Phase 2.

```

```


----------
# 3.Client (Application)

Client determine the objects possibly involved in write by the information available in current request and by using static analyzer (described in the following Coordinator section).

```
router:     Router that has knowledge of which coordinator takes care of the object
seqfrom:    First sequence number for which current client is responsble
seqto:      Last sequence number for which current client is responsble
cfg:        Configuration for client side
subjects:   Subject ID list (used for random payload generation)
resources:  Resource ID list
actions:    Action name list
analyzer:   Static analyzer that decides which object should process first
mode:       Running mode (oplock for Phase 1/2 or mvcc for Phase 3)
 
def run():
    for i from seqfrom to seqto:
        # 0.Create request according to the running mode
        req = EvalReq() if mode == oplock else EvalReqMvcc()
        req.seq = i 

        # 1.Generate specific or random payload (req.subject, resource, action)
        #   Since it's exactly the same as that in Phase 2, so we omit the detail here...

        # 2.Send to correspondent coordinator
        if mode == oplock:
            sc = router.get_sc(req.subject)
            send(('reqapp', req,), to=sc)
        else:
            x = self.analyzer.obj(req, 1)
            co = router.route(x)
            send(('reqapp', req,), to=co)

    # 3.Wait for exit command
    await(received('done'))

def receive(msg=('respapp', seq, result,), from_=sc):
    output decision or perform other operation
```


---------------
# 4.Coordinator

```

```

## AdminMvcc (State managment helper class)

```

```

## Analyzer (Static analysis helper class)

Static analyzer that preread policy rule to make decision of:
    Which object could possibly be involved in write
    Which object should be accessed first to reduce latency
    Is the request readonly?

```
def obj(req, i):
    wrtobj = mightWriteObj(req)

    # If written object is decided, choose it as second to process
    # Otherwise (readonly request or more than 1 written object which cannot be decided)
    # Choose subject as the first object to handle randomly
    if len(wrtobj) == 1:
        rdobj = req.subject if req.subject != wrtobj[0] else req.resource
        return rdobj if i == 1 else wrtobj[0]
    else:
        return req.subject if i == 1 else req.resource

def readonly(req):
    return not mightWriteObj(req)

def mightWriteObj(req):
    pass
```


----------
# 5.Worker


------------
# 6.Database
