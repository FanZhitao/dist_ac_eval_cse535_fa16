
Name: Zhitao Fan, Chen Dai

### (I) Data Structure

Message

### (II) Master

Master is the bootstrap process of whole system which reads configuration file and starts all other processes to make system ready for testing.

```
# Master

run():
    cfg = readConfigFile(argv[1])
    workload = argv[2]

    # 1.Create and start DB and workers
    db = create DB process
    w = create Workers with specific number in config
    setup(db, cfg['db'])
    start(w)
    start(db)

    # 2.Create and start coordinators
    co = create Coordinators with specific number in config
    start(co)

    # 3.Assign role to coordinators according to total number of subjects and resources
    r = create Router
    r.assign(get_subjects(), get_resources(), co)
    for c in co:
        send(('routetbl', router), to=c)

    # 4.Create application as client and start testing
    #   Divide total requests evenly and assign sequence number of request to each application
    apps = create Applications with specific number in config
    for each app in apps:
        setup(app, router, seqfrom, seqto)
    start(app)
```

Router assigns subject and resource onto coordinators in pool. The following algorithm tries to distribute uniformly. And if conflict, use linear probing simply to address that.

```
# Router

scmap = <subjectID, coordinator>
rcmap = <resourceID, coordinator>

assign(subjects, resources, co):
    total = length of co
    free = total
    occupy = array in free length with all false inside

    # 1.Assign subject to coordinator
    # If found conflict, find next free coordinator (linear probing)
    for sub in subjects
        idx = hash(sub) % total
        if occupy[idx] is True and free > 0
            idx = self.search_free_co(free, occupy)
            free--
        scmap[sub] = co[idx]
        occupy[idx] = True

    # 2.Assign resource to coordinator, same as above
    for res in resources
        idx = hash(res) % total
        if occupy[idx] is True and free > 0:
            idx = self.search_free_co(free, occupy)
            free--
        rcmap[res] = co[idx]
        occupy[idx] = True

# Search free list to find next one
search_free_co(self, free, occupy):
    for i in length of occupy
        if occupy[i] is False
            occupy[i] = True
            return i
```


### (III) Application

Now the system is ready for testing. Each application process will start sending request to correspendent coordinator immediately upon running up. The requests carry payload which is described in the configuration file.

```
# parameters passed from Master

1.router: route table of all coordinators
2.seqfrom: the starting sequence number of request that current application should send
3.seqno: the ending sequence number of request that current application should send
4.subjects: all subject ID
5.resources: all resource ID

def run():
    for i from seqfrom to seqto
        # 1.Generate specific or random payload
        req = EvalReq()
        req.seq = i
        prefix = 'req' + i
        req.subject = cfg[prefix + '.subject'] or if not configured, choose one from subject list randomly
        req.resource = cfg[prefix + '.resource'] or if not configured, choose one from resource list randomly
        req.action = cfg[prefix + '.action']

        # 2.Send to correspondent subject coordinator
        sc = router.scmap[req.subject]
        send(('reqapp', req,), to=sc)

    # 3.Wait for exit command
    await(received('done'))

# Wait for receiving request
def receive(msg=('respapp', seq, result,), from_=sc):
    log.info("App - Received request #seq-[%d] result: %s from SC %s", seq, result, sc)
```


### (IV) Coordinator

forwardToRC(req):
    assignId(req)               --step 3
    setupAdmin(req)
    addUpdatedAttr(req)
    rc = lookup(req.resource)
    send(rc, self, req)         --step 4

handleConflict(worker, resp):
    if findConflict(resp)       --step 9: Optimistic locking
        restart(resp.id)
    else:
        add(tentativeAttrs, resp.wAttr) --Update to block conflicting requests
        send(rc, self, req)     --step 10
        wait(rc, ack)
        if ack == success:
            commit(DB, resp.wAttr)  --step 13
	        clearAdmin(resp.scAdmin)
            send(app, resp)         --step 14
        else:
            restart(resp.id)

assignId(req):
    req.id = generate()

setupAdmin(req):
    req.scAdmin = createAdmin()

addUpdatedAttr(req):
    req.tAttr = tentativeAttrs

findConflict(resp):
    return isIn(tentativeAttrs, resp.wAttr) or
            isIn(tentativeAttrs, resp.rAttr)

restart(requestId):
	req = getRequestById(requestId)
	clearAdmin(req.scAdmin)
	forwardToRC(req)
	

-- (III) Resource Coordinator
-- Step 5: Sets up the administration for the resource
-- Step 6: Assigns the request to a worker
-- Step 11: checks its administration, if there are no conflicts, 
        -- executes the updates of resource attributes, 
        -- clears its administration for this evaluation
		--
		-- If it detects a conflicting update of a resource attribute,
		-- it notifies the sc.
-- Step 12: Acknowledges success to the first coordinator

forwardToWorker(sc, req):
    setupAdmin(req)             --step 5
    worker = getFromPool()
    send(worker, sc, req)       --step 6

checkConflict(sc, req):         --step 11
	if (hasDetectedAConflicting()):
		nofityResourceConflict(sc)
	else:
    	if checkAdmin(req.rcAdmin):
        	updateResAttr(DB)
    	clearAdmin(req)
    	ackSuccess(sc)           --step 12

setupAdmin(req):
    req.rcAdmin = createAdmin()

restart(req):
    clearAdmin(req.rcAdmin)

-- (IV) Worker
-- Step 7: Evaluates the policy for this request
-- Step 8: Sends the result to the coordinator responsible for the subject

evaluatePolicy(sc, req):
    decision = doEvaluate(DB, req)
    rAttr = getReadAttr(DB, req)
    wAttr = getUpdateAttr(DB, req)
    resp = createResponse(req, decision, rAttr, wAttr)   --step 7
    send(sc, resp)                                       --step 8


-- High level Data Structure
-- 1.req: request for policy evaluation
    -- subject: subject Id
    -- resource: resource Id
    -- id: assigned global Id
    -- app: application instance
    -- scAdmin: subject administration Id
    -- rcAdmin: resource administration Id
    -- tAttr: tentatively updated attribute list
-- 2.scMap: mapping from subjectId to Subject Coordinator instance
-- 4.rcMap: mapping from resourceId to Resource Coordinator instance
-- 5.tentativeAttrs: Tentatively updated attributes
-- 6.resp: response of evaluation
    -- id: assigned global Id
    -- app: application instance
    -- scAdmin: subject administration Id
    -- rcAdmin: resource administration Id
    -- wAttr: attributes that should be updated
    -- rAttr: attributes that were read
